---
declaration:
  call: declare
  version: 0.1
  description: Description placeholder for 'bgk-BOT'
  method: post
  accepts: json
  returns: json
  namespace: backoffice
  allowlist:
    body:
      - field: message
        type: string
        description: Body field 'message'
      - field: sender
        type: string
        description: Body field 'sender'
      - field: authorId
        type: string
        description: "Parameter 'authorId'"
      - field: holidayNames
        type: string
        description: "Body field 'holidayNames'"
      - field: holidays
        type: string
        description: "Body field 'holidays'"  

extract_data:
  assign:
    currentDate: ${new Date().toISOString().split('T')[0]}
    sender: ${incoming.body.sender}
    authorId: ${incoming.body.authorId}
    holidays: ${incoming.body.holidays}
    holidayNames: ${incoming.body.holidayNames}
    event: ""
    isOrgAvailable: false
    context: []

assignBgkConfig:
  assign:
    strictness: "[#BGK_STRICTNESS]"
    max_tokens: "[#BGK_MAX_TOKENS]"
    documents: "[#BGK_DOCUMENTS]"
    index_name: "[#BGK_INDEX_NAME]"
    query_type: "[#BGK_QUERY_TYPE]"
    system_message: "[#BGK_SYSTEM_MESSAGE]"
    search_endpoint: "[#BGK_SEARCH_ENDPOINT]"
    chatbot_external_key: "[#BGK_CHATBOT_EXTERNAL_KEY]"
    embedded_endpoint: "[#BGK_EMBEDDED_ENDPOINT_AZURE]"
    chatbot_external_api_key: "[#BGK_CHATBOT_EXTERNAL_API_KEY]"
    chatbot_external_bot_url: "[#BGK_CHATBOT_EXTERNAL_BOT_URL]"
    semantic_configuration: "[#BGK_SEMANTIC_CONFIGURATION]"

logstepAZURESAADAME:
  log: ${incoming.body.message}

check_if_client_bot_is_active:
  switch:
    - condition: ${[#BGK_ACTIVE] === true}
      next: assign_data_sources
  next: get_organization_bot_answer_config

assign_data_sources:
  assign:
    data_sources:
      - type: azure_search
        parameters:
          endpoint: ${search_endpoint}
          index_name: ${index_name}
          semantic_configuration: ${semantic_configuration}
          query_type: ${query_type}
          in_scope: true
          strictness: ${parseInt(strictness ?? '3')}
          top_n_documents: ${parseInt(documents ?? '5')}
          authentication:
            type: api_key
            key: ${chatbot_external_key}
          embedding_dependency:
            type: endpoint
            endpoint: ${embedded_endpoint}
            authentication:
              type: api_key
              key: ${chatbot_external_api_key}

logstepAZUREDS:
  log: ${data_sources}

get_chat_messages:
  call: http.post
  args:
    url: "[#CHATBOT_RESQL]/get-llm-chat-messages"
    body:
      chatId: ${sender}
  result: chat_messages_res

prepare_messages:
  call: http.post
  args:
    url: "[#CHATBOT_DMAPPER_HBS]/prepare-llm-messages"
    headers:
      type: json
    body:
      prompt_message: "${system_message} The current date is ${currentDate}"
      messages: ${chat_messages_res.response.body}
      new_message: ${incoming.body.message ?? ''}
  result: prepare_messages_res

assign_messages:
  assign:
    messages: ${prepare_messages_res.response.body}

logstepAZUREMSG:
  log: ${messages}

post_answer:
  call: http.post
  args:
    url: "${chatbot_external_bot_url}"
    headers:
      Content-Type: application/json
      api-key: ${chatbot_external_api_key}
    body:
      data_sources: ${data_sources}
      messages: ${messages}
      temperature: 0
      max_tokens: ${parseInt(max_tokens ?? '1000')}
      stream: false
      frequency_penalty: 0
      presence_penalty: 0
  result: test
  
logstepAZUREBOT:
  log: ${test}

assign_context:
  assign:
    context: ${test.response.body.choices[0].message.context}

assign_value:
  assign:
    correct_value:
      - recipient_id: ${sender}
        text: ${test.response.body.choices[0].message.content.replace(/\n/g,"\\n").replace(" \. ", ". ")}
        context: ${context}
  next: check_value

check_value:
  switch:
    - condition: ${correct_value === 'ERROR'}
      next: return_value
    - condition: ${correct_value.map((item) => item.text)[0] === '$backoffice' || correct_value.map((item) => item.text)[0].startsWith('$backoffice')}
      next: get_organization_base_config
    - condition: ${correct_value.map((item) => item.text)[0].startsWith('$validate_')}
      next: assign_validation_event  
  next: format_messages

get_organization_base_config:
  call: http.post
  args:
    url: "[#CHATBOT_RESQL]/get-organization-base-config"
  result: org_base_config_res
  next: assign_organization_base_config

assign_organization_base_config:
  assign:
    base_config: ${org_base_config_res.response.body[0]}
  next: check_if_organization_is_available_all_time

check_if_organization_is_available_all_time:
  switch:
    - condition: ${base_config.isAvailableAllTime === 'true'}
      next: get_all_available_csas
  next: get_organization_working_details

get_organization_working_details:
  call: http.post
  args:
    url: "[#CHATBOT_RESQL]/get-is-organization-available"
    body:
      holidays: ${holidays}
      holiday_names: ${holidayNames}
      current_timestamp: ${new Date().toISOString()}
  result: org_res
  next: assign_organization_details

assign_organization_details:
  assign:
    org_details: ${org_res.response.body[0]}
  next: check_if_organization_is_available

check_if_organization_is_available:
  switch:
    - condition: ${org_details.isWithinWorkingTime === true && org_details.isWithinWorkingDays === true && org_details.isAllowedToWorkAtHolidays === true}
      next: get_all_available_csas
    - condition: ${org_details.isWithinWorkingTime === true && org_details.isWithinWorkingDays === true && org_details.isAllowedToWorkAtHolidays === false && org_details.isHoliday == true}
      next: get_organization_bot_answer_config
    - condition: ${org_details.isWithinWorkingTime === true && org_details.isWithinWorkingDays === true && org_details.isAllowedToWorkAtHolidays === false && org_details.isHoliday == false}
      next: get_all_available_csas
  next: get_organization_bot_answer_config

get_all_available_csas:
  call: http.post
  args:
    url: "[#CHATBOT_RESQL]/get-all-available-customer-support-agents"
  result: csas_res
  next: assign_available_csas

assign_available_csas:
  assign:
    available_csas: ${csas_res.response.body.length}
  next: check_if_csas_are_available

check_if_csas_are_available:
  switch:
    - condition: ${available_csas == 0}
      next: get_organization_bot_answer_config
  next: assign_organization_available

assign_organization_available:
  assign:
    isOrgAvailable: true
  next: get_organization_bot_answer_config
  
return_value:
  return: ${correct_value}
  next: end

assign_validation_event:
  assign:
    correct_value:
      - recipient_id: ${sender}
        text: ${correct_value.map((item) => item.text)[0].replace('$validate_', '')}
        context: ${context}
    event: "waiting_validation"
  next: change_chat_status 

change_chat_status:
  call: http.post
  args:
    url: "[#CHATBOT_RUUTER_PUBLIC]/chats/change-status"
    body:
      chatId: ${sender}
      status: "VALIDATING"
      holidays: ${holidays}
      holidayNames: ${holidayNames}
  result: change_chat_status_res
  next: check_chat_status_result

check_chat_status_result:
  switch:
    - condition: ${change_chat_status_res.response.body.response === "Status Changed Successfully"}
      next: format_messages
  next: assign_unavailable_message

assign_unavailable_message:
  assign:
    correct_value:
      - recipient_id: ${sender}
        text: "Edasine lahendamine toimub vastavalt pöördumiste protsessile väljaspool AI-assistendi lahendust."
        context: ${context}
    event: ""
  next: format_messages

get_organization_bot_answer_config:
  call: http.post
  args:
    url: "[#CHATBOT_RESQL]/get-organization-bot-answer-config"
  result: bot_answer_config_res
  next: assign_organization_bot_answer_config

assign_organization_bot_answer_config:
  assign:
    bot_answer_config: ${bot_answer_config_res.response.body[0]}
  next: assign_back_office_event

assign_back_office_event:
  assign:
    correct_value:
      - recipient_id: ${sender}
        text: ${bot_answer_config.askToForwardToCsaMessage}
        context: ${context}
    event: "${bot_answer_config.isAskToForwardToCsa === 'true' && isOrgAvailable === true ? 'ask_to_forward_to_csa' : ''}"
  next: format_messages

format_messages:
  call: http.post
  args:
    url: "[#CHATBOT_DMAPPER_HBS]/llm_responses_to_messages"
    headers:
      type: json
    body:
      data:
        {
          "botMessages": "${correct_value}",
          "chatId": "${sender}",
          "authorId": "${authorId}",
          "authorFirstName": "",
          "authorLastName": "",
          "event": "${event ?? ''}",
          "authorTimestamp": "${new Date().toISOString()}",
          "created": "${new Date().toISOString()}",
        }
  result: converted_messages_res
  next: return_formatted_value

return_formatted_value:
  return: ${converted_messages_res.response.body}
  next: end 
